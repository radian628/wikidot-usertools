{
  "version": 3,
  "sources": ["../../node_modules/events/events.js", "../../src/common/workerify.ts", "../../node_modules/graphology/src/utils.js", "../../node_modules/graphology/src/errors.js", "../../node_modules/graphology/src/data.js", "../../node_modules/graphology/src/attributes/nodes.js", "../../node_modules/graphology/src/attributes/edges.js", "../../node_modules/graphology/src/iteration/edges.js", "../../node_modules/graphology/src/iteration/neighbors.js", "../../node_modules/graphology/src/iteration/adjacency.js", "../../node_modules/graphology/src/serialization.js", "../../node_modules/graphology/src/graph.js", "../../node_modules/graphology/src/classes.js", "../../node_modules/graphology/src/endpoint.esm.js", "../../src/wiki-article-graph/wiki-article-graph-worker-interface.ts", "../../src/wiki-article-graph/wiki-article-graph-worker.ts"],
  "sourcesContent": ["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n", "import { v4 } from \"uuid\";\r\n\r\ntype InterfaceWithMethods = Record<string, (...args: any[]) => any>;\r\n\r\nexport type WorkerifyInterface<T extends InterfaceWithMethods> = {\r\n  [K in keyof T]: (\r\n    ...args: Parameters<T[K]>\r\n  ) => ReturnType<T[K]> extends Promise<any>\r\n    ? ReturnType<T[K]>\r\n    : Promise<ReturnType<T[K]>>;\r\n};\r\n\r\ntype WorkerifyRequest<T extends InterfaceWithMethods> = {\r\n  [K in keyof T]: {\r\n    type: K;\r\n    contents: Parameters<T[K]>;\r\n    _discriminator: string;\r\n    id: string;\r\n  };\r\n}[keyof T];\r\n\r\ntype WorkerifyResponse<T extends InterfaceWithMethods> = {\r\n  [K in keyof T]: {\r\n    contents: ReturnType<T[K]>;\r\n    _discriminator: string;\r\n    id: string;\r\n  };\r\n}[keyof T];\r\n\r\nexport function workerifyServer<I extends InterfaceWithMethods>(\r\n  i: I,\r\n  discriminator: string,\r\n  onReceive: (cb: (req: any) => any) => () => void,\r\n  send: (res: any) => void\r\n) {\r\n  let inf = i;\r\n  const unsub = onReceive(async (req: any) => {\r\n    if (!req || req._discriminator !== discriminator) {\r\n      return;\r\n    }\r\n\r\n    const typedReq: WorkerifyRequest<I> = req;\r\n\r\n    const responseContents = await inf[typedReq.type](...typedReq.contents);\r\n\r\n    send({\r\n      contents: responseContents,\r\n      _discriminator: discriminator,\r\n      id: typedReq.id,\r\n    });\r\n  });\r\n\r\n  return {\r\n    unsub,\r\n    setInterface(i: I) {\r\n      inf = i;\r\n    },\r\n  };\r\n}\r\n\r\nexport function workerifyClient<I extends InterfaceWithMethods>(\r\n  discriminator: string,\r\n  onReceive: (cb: (req: any) => any) => () => void,\r\n  send: (req: any) => void\r\n): WorkerifyInterface<I> {\r\n  return new Proxy({} as I, {\r\n    get(i, prop) {\r\n      return (...args: any[]) => {\r\n        const id = v4();\r\n        const req = {\r\n          type: prop,\r\n          contents: args,\r\n          _discriminator: discriminator,\r\n          id,\r\n        };\r\n\r\n        return new Promise((resolve, reject) => {\r\n          onReceive((res) => {\r\n            if (!res || res._discriminator !== discriminator) {\r\n              return;\r\n            }\r\n\r\n            const typedRes: WorkerifyResponse<I> = res;\r\n\r\n            if (typedRes.id === id) {\r\n              resolve(typedRes.contents);\r\n            }\r\n          });\r\n          send(req);\r\n        });\r\n      };\r\n    },\r\n  });\r\n}\r\n", "/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  // NOTE: as per https://github.com/graphology/graphology/issues/149\n  // this function has been loosened not to reject object instances\n  // coming from other JavaScript contexts. It has also been chosen\n  // not to improve it to avoid obvious false positives and avoid\n  // taking a performance hit. People should really use TypeScript\n  // if they want to avoid feeding subtly irrelvant attribute objects.\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n\n/**\n * Chains multiple iterators into a single iterator.\n *\n * @param {...Iterator} iterables\n * @returns {Iterator}\n */\nexport function chain() {\n  const iterables = arguments;\n  let current = null;\n  let i = -1;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let step = null;\n\n      do {\n        if (current === null) {\n          i++;\n          if (i >= iterables.length) return {done: true};\n          current = iterables[i][Symbol.iterator]();\n        }\n        step = current.next();\n        if (step.done) {\n          current = null;\n          continue;\n        }\n        break;\n        // eslint-disable-next-line no-constant-condition\n      } while (true);\n\n      return step;\n    }\n  };\n}\n\n/**\n * Maps the given iterable using the provided function.\n *\n * @param {Iterable} iterable\n * @param {Function} fn\n * @returns {Iterator}\n */\nexport function map(iterable, fn) {\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      const step = iterable.next();\n      if (step.done) return step;\n      return {value: fn(step.value), done: false};\n    }\n  };\n}\n\nexport function emptyIterator() {\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      return {done: true};\n    }\n  };\n}\n", "/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n", "/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n\nEdgeData.prototype.attach = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  // Handling source\n  this.source[outKey][target] = this;\n\n  if (this.undirected && source === target) return;\n\n  // Handling target\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.attachMulti = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Handling source\n  const adj = this.source[outKey];\n  const head = adj[target];\n\n  if (typeof head === 'undefined') {\n    adj[target] = this;\n\n    // Self-loop optimization\n    if (!(this.undirected && source === target)) {\n      // Handling target\n      this.target[inKey][source] = this;\n    }\n\n    return;\n  }\n\n  // Prepending to doubly-linked list\n  head.previous = this;\n  this.next = head;\n\n  // Pointing to new head\n  // NOTE: use mutating swap later to avoid lookup?\n  adj[target] = this;\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.detach = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  delete this.source[outKey][target];\n\n  // No-op delete in case of undirected self-loop\n  delete this.target[inKey][source];\n};\n\nEdgeData.prototype.detachMulti = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Deleting from doubly-linked list\n  if (this.previous === undefined) {\n    // We are dealing with the head\n\n    // Should we delete the adjacency entry because it is now empty?\n    if (this.next === undefined) {\n      delete this.source[outKey][target];\n\n      // No-op delete in case of undirected self-loop\n      delete this.target[inKey][source];\n    } else {\n      // Detaching\n      this.next.previous = undefined;\n\n      // NOTE: could avoid the lookups by creating a #.become mutating method\n      this.source[outKey][target] = this.next;\n\n      // No-op delete in case of undirected self-loop\n      this.target[inKey][source] = this.next;\n    }\n  } else {\n    // We are dealing with another list node\n    this.previous.next = this.next;\n\n    // If not last\n    if (this.next !== undefined) {\n      this.next.previous = this.previous;\n    }\n  }\n};\n", "/**\n * Graphology Node Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject} from '../utils';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\nconst NODE = 0;\nconst SOURCE = 1;\nconst TARGET = 2;\nconst OPPOSITE = 3;\n\nfunction findRelevantNodeData(\n  graph,\n  method,\n  mode,\n  nodeOrEdge,\n  nameOrEdge,\n  add1,\n  add2\n) {\n  let nodeData, edgeData, arg1, arg2;\n\n  nodeOrEdge = '' + nodeOrEdge;\n\n  if (mode === NODE) {\n    nodeData = graph._nodes.get(nodeOrEdge);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" node in the graph.`\n      );\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  } else if (mode === OPPOSITE) {\n    nameOrEdge = '' + nameOrEdge;\n\n    edgeData = graph._edges.get(nameOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nameOrEdge}\" edge in the graph.`\n      );\n\n    const source = edgeData.source.key;\n    const target = edgeData.target.key;\n\n    if (nodeOrEdge === source) {\n      nodeData = edgeData.target;\n    } else if (nodeOrEdge === target) {\n      nodeData = edgeData.source;\n    } else {\n      throw new NotFoundGraphError(\n        `Graph.${method}: the \"${nodeOrEdge}\" node is not attached to the \"${nameOrEdge}\" edge (${source}, ${target}).`\n      );\n    }\n\n    arg1 = add1;\n    arg2 = add2;\n  } else {\n    edgeData = graph._edges.get(nodeOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" edge in the graph.`\n      );\n\n    if (mode === SOURCE) {\n      nodeData = edgeData.source;\n    } else {\n      nodeData = edgeData.target;\n    }\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  }\n\n  return [nodeData, arg1, arg2];\n}\n\nfunction attachNodeAttributeGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes[name];\n  };\n}\n\nfunction attachNodeAttributesGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {\n    const [data] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge\n    );\n\n    return data.attributes;\n  };\n}\n\nfunction attachNodeAttributeChecker(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\nfunction attachNodeAttributeSetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, value] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeRemover(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesReplacer(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesMerger(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst NODE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachNodeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachNodeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachNodeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachNodeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachNodeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachNodeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachNodeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachNodeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachNodeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachNodeAttributesMethods(Graph) {\n  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For nodes\n    attacher(Graph, name('Node'), NODE);\n\n    // For sources\n    attacher(Graph, name('Source'), SOURCE);\n\n    // For targets\n    attacher(Graph, name('Target'), TARGET);\n\n    // For opposites\n    attacher(Graph, name('Opposite'), OPPOSITE);\n  });\n}\n", "/**\n * Graphology Edge Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject, getMatchingEdge} from '../utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from '../errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesMerger(Class, method, type) {\n  /**\n   * Merge the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesUpdater(Class, method, type) {\n  /**\n   * Update the attributes of the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + updater;\n\n      updater = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst EDGE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachEdgeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachEdgeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachEdgeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachEdgeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachEdgeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachEdgeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachEdgeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachEdgeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachEdgeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachEdgeAttributesMethods(Graph) {\n  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n", "/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport {chain, emptyIterator} from '../utils';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(breakable, object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction forEachMulti(breakable, object, callback, avoid) {\n  let edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    edgeData = object[k];\n\n    do {\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (breakable && shouldBreak) return edgeData.key;\n\n      edgeData = edgeData.next;\n    } while (edgeData !== undefined);\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let edgeData;\n  let i = 0;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      do {\n        if (!edgeData) {\n          if (i >= l) return {done: true};\n\n          const k = keys[i++];\n\n          if (k === avoid) {\n            edgeData = undefined;\n            continue;\n          }\n\n          edgeData = object[k];\n        } else {\n          edgeData = edgeData.next;\n        }\n      } while (!edgeData);\n\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    }\n  };\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(breakable, object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    ) &&\n    breakable\n  )\n    return edgeData.key;\n}\n\nfunction forEachForKeyMulti(breakable, object, k, callback) {\n  let edgeData = object[k];\n\n  if (!edgeData) return;\n\n  let shouldBreak = false;\n\n  do {\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n\n    edgeData = edgeData.next;\n  } while (edgeData !== undefined);\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  let edgeData = object[k];\n\n  if (edgeData.next !== undefined) {\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        if (!edgeData) return {done: true};\n\n        const value = {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        };\n\n        edgeData = edgeData.next;\n\n        return {\n          done: false,\n          value\n        };\n      }\n    };\n  }\n\n  let done = false;\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      if (done === true) return {done: true};\n      done = true;\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    }\n  };\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    return Array.from(graph._edges.keys());\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(breakable, graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (breakable && shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return emptyIterator();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let step, data;\n\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        step = iterator.next();\n\n        if (step.done) return step;\n\n        data = step.value;\n\n        if (shouldFilter && data.undirected !== mask) continue;\n\n        break;\n      }\n\n      const value = {\n        edge: data.key,\n        attributes: data.attributes,\n        source: data.source.key,\n        target: data.target.key,\n        sourceAttributes: data.source.attributes,\n        targetAttributes: data.target.attributes,\n        undirected: data.undirected\n      };\n\n      return {value, done: false};\n    }\n  };\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(\n  breakable,\n  multi,\n  type,\n  direction,\n  nodeData,\n  callback\n) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(breakable, nodeData.in, callback);\n\n      if (breakable && found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(\n        breakable,\n        nodeData.out,\n        callback,\n        !direction ? nodeData.key : undefined\n      );\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(breakable, nodeData.undirected, callback);\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForNode(false, multi, type, direction, nodeData, function (key) {\n    edges.push(key);\n  });\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = emptyIterator();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : undefined)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  breakable,\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(breakable, sourceData.in, target, callback);\n\n      if (breakable && found) return found;\n    }\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      (direction || sourceData.key !== target)\n    ) {\n      found = fn(breakable, sourceData.out, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(breakable, sourceData.undirected, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForPath(\n    false,\n    type,\n    multi,\n    direction,\n    sourceData,\n    target,\n    function (key) {\n      edges.push(key);\n    }\n  );\n\n  return edges;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = emptyIterator();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out &&\n      (direction || sourceData.key !== target)\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(false, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        false,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        false,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(true, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        true,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        true,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return emptyIterator();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n", "/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport {chain, emptyIterator} from '../utils';\n\nimport {NotFoundGraphError, InvalidArgumentsGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Helpers.\n */\nfunction CompositeSetWrapper() {\n  this.A = null;\n  this.B = null;\n}\n\nCompositeSetWrapper.prototype.wrap = function (set) {\n  if (this.A === null) this.A = set;\n  else if (this.B === null) this.B = set;\n};\n\nCompositeSetWrapper.prototype.has = function (key) {\n  if (this.A !== null && key in this.A) return true;\n  if (this.B !== null && key in this.B) return true;\n  return false;\n};\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectOnce(breakable, visited, nodeData, object, callback) {\n  for (const k in object) {\n    const edgeData = object[k];\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited && visited.has(neighborData.key)) continue;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (breakable && shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighbor(breakable, type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.undirected,\n        callback\n      );\n\n    if (typeof direction === 'string')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData[direction],\n        callback\n      );\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.in,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.in);\n    }\n    if (direction !== 'in') {\n      found = forEachInObjectOnce(\n        breakable,\n        visited,\n        nodeData,\n        nodeData.out,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    found = forEachInObjectOnce(\n      breakable,\n      visited,\n      nodeData,\n      nodeData.undirected,\n      callback\n    );\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  const neighbors = [];\n\n  forEachNeighbor(false, type, direction, nodeData, function (key) {\n    neighbors.push(key);\n  });\n\n  return neighbors;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let i = 0;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let neighborData = null;\n\n      do {\n        if (i >= l) {\n          if (visited) visited.wrap(object);\n          return {done: true};\n        }\n\n        const edgeData = object[keys[i++]];\n\n        const sourceData = edgeData.source;\n        const targetData = edgeData.target;\n\n        neighborData = sourceData === nodeData ? targetData : sourceData;\n\n        if (visited && visited.has(neighborData.key)) {\n          neighborData = null;\n          continue;\n        }\n      } while (neighborData === null);\n\n      return {\n        done: false,\n        value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n      };\n    }\n  };\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createDedupedObjectIterator(null, nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createDedupedObjectIterator(null, nodeData, nodeData[direction]);\n  }\n\n  let iterator = emptyIterator();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighbor(\n      false,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return forEachNeighbor(\n      true,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return emptyIterator();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n", "/**\n * Graphology Adjacency Iteration\n * ===============================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nexport function forEachAdjacency(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n", "/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used by the graph serialization schemes.\n */\nimport {InvalidArgumentsGraphError} from './errors';\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {string} type - The graph's type.\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(type, key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (type === 'mixed' && data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n    );\n\n  if (!('key' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized node is missing its key.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n    );\n\n  if (!('source' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its source.'\n    );\n\n  if (!('target' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its target.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.'\n    );\n}\n", "/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport attachNodeAttributesMethods from './attributes/nodes';\nimport attachEdgeAttributesMethods from './attributes/edges';\nimport attachEdgeIterationMethods from './iteration/edges';\nimport attachNeighborIterationMethods from './iteration/neighbors';\nimport {forEachAdjacency} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalIdStartingFromRandomByte,\n  validateHints\n} from './utils';\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source);\n  let targetData = graph._nodes.get(target);\n  let edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are consistent\n      if (edgeData.source.key !== source || edgeData.target.key !== target) {\n        // If source or target inconsistent\n        if (\n          !undirected ||\n          edgeData.source.key !== target ||\n          edgeData.target.key !== source\n        ) {\n          // If directed, or source/target aren't flipped\n          throw new UsageGraphError(\n            `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n          );\n        }\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    const info = [alreadyExistingEdgeData.key, false, false, false];\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return info;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return info;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  let sourceWasAdded = false;\n  let targetWasAdded = false;\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n    sourceWasAdded = true;\n\n    if (source === target) {\n      targetData = sourceData;\n      targetWasAdded = true;\n    }\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n    targetWasAdded = true;\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return [edge, true, sourceWasAdded, targetWasAdded];\n}\n\n/**\n * Internal method used to drop an edge.\n *\n * @param  {Graph}    graph    - Target graph.\n * @param  {EdgeData} edgeData - Data of the edge to drop.\n */\nfunction dropEdgeFromData(graph, edgeData) {\n  // Dropping the edge from the register\n  graph._edges.delete(edgeData.key);\n\n  // Updating related degrees\n  const {source: sourceData, target: targetData, attributes} = edgeData;\n\n  const undirected = edgeData.undirected;\n\n  const isSelfLoop = sourceData === targetData;\n\n  if (undirected) {\n    sourceData.undirectedDegree--;\n    targetData.undirectedDegree--;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops--;\n      graph._undirectedSelfLoopCount--;\n    }\n  } else {\n    sourceData.outDegree--;\n    targetData.inDegree--;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops--;\n      graph._directedSelfLoopCount--;\n    }\n  }\n\n  // Clearing index\n  if (graph.multi) edgeData.detachMulti();\n  else edgeData.detach();\n\n  if (undirected) graph._undirectedSize--;\n  else graph._directedSize--;\n\n  // Emitting\n  graph.emit('edgeDropped', {\n    key: edgeData.key,\n    attributes,\n    source: sourceData.key,\n    target: targetData.key,\n    undirected\n  });\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instancePrefix = 'geid_' + INSTANCE_ID() + '_';\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = instancePrefix + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.out.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.undirected.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return (\n        (typeof nodeData.out !== 'undefined' &&\n          nodeData.out.hasOwnProperty(target)) ||\n        (typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected.hasOwnProperty(target))\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's inbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's outbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's inbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's outbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n      loops += nodeData.directedLoops * 2;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key;\n    const target = data.target.key;\n\n    if (node === source) return target;\n    if (node === target) return source;\n\n    throw new NotFoundGraphError(\n      `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n    );\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return [node, false];\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return [node, false];\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    let edgeData;\n\n    // Removing attached edges\n    // NOTE: we could be faster here, but this is such a pain to maintain\n    if (this.type !== 'undirected') {\n      for (const neighbor in nodeData.out) {\n        edgeData = nodeData.out[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n\n      for (const neighbor in nodeData.in) {\n        edgeData = nodeData.in[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (this.type !== 'directed') {\n      for (const neighbor in nodeData.undirected) {\n        edgeData = nodeData.undirected[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0];\n      const target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single directed edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropDirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const edgeData = getMatchingEdge(this, source, target, 'directed');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropDirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single undirected edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropUndirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    const edgeData = getMatchingEdge(this, source, target, 'undirected');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropUndirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    // Clearing structure index\n    const iterator = this._nodes.values();\n\n    let step;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      step.value.clear();\n    }\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method updating the graph's attributes.\n   *\n   * @param  {function} updater - Function used to update the attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given updater is not a function.\n   */\n  updateAttributes(updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttributes: provided updater is not a function.'\n      );\n\n    this._attributes = updater(this._attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'update',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData, sourceData, targetData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      sourceData = edgeData.source;\n      targetData = edgeData.target;\n\n      edgeData.attributes = updater(\n        edgeData.key,\n        edgeData.attributes,\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.undirected\n      );\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, false, this, callback);\n  }\n  forEachAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, true, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's assymetric adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAssymetricAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, false, this, callback);\n  }\n  forEachAssymetricAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, true, this, callback);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    return Array.from(this._nodes.keys());\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const step = iterator.next();\n        if (step.done) return step;\n        const data = step.value;\n        return {\n          value: {node: data.key, attributes: data.attributes},\n          done: false\n        };\n      }\n    };\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(this.type, key, data);\n    });\n\n    return {\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      },\n      attributes: this.getAttributes(),\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance directly\n    if (data instanceof Graph) {\n      // Nodes\n      data.forEachNode((n, a) => {\n        if (merge) this.mergeNode(n, a);\n        else this.addNode(n, a);\n      });\n\n      // Edges\n      data.forEachEdge((e, a, s, t, _sa, _ta, u) => {\n        if (merge) {\n          if (u) this.mergeUndirectedEdgeWithKey(e, s, t, a);\n          else this.mergeDirectedEdgeWithKey(e, s, t, a);\n        } else {\n          if (u) this.addUndirectedEdgeWithKey(e, s, t, a);\n          else this.addDirectedEdgeWithKey(e, s, t, a);\n        }\n      });\n\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list, node, edge;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        node = list[i];\n\n        // Validating\n        validateSerializedNode(node);\n\n        // Adding the node\n        const {key, attributes} = node;\n\n        if (merge) this.mergeNode(key, attributes);\n        else this.addNode(key, attributes);\n      }\n    }\n\n    if (data.edges) {\n      let undirectedByDefault = false;\n\n      if (this.type === 'undirected') {\n        undirectedByDefault = true;\n      }\n\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        edge = list[i];\n\n        // Validating\n        validateSerializedEdge(edge);\n\n        // Adding the edge\n        const {\n          source,\n          target,\n          attributes,\n          undirected = undirectedByDefault\n        } = edge;\n\n        let method;\n\n        if ('key' in edge) {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdgeWithKey\n              : this.mergeDirectedEdgeWithKey\n            : undirected\n            ? this.addUndirectedEdgeWithKey\n            : this.addDirectedEdgeWithKey;\n\n          method.call(this, edge.key, source, target, attributes);\n        } else {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdge\n              : this.mergeDirectedEdge\n            : undirected\n            ? this.addUndirectedEdge\n            : this.addDirectedEdge;\n\n          method.call(this, source, target, attributes);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n    graph.replaceAttributes(assign({}, this.getAttributes()));\n    return graph;\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @param  {object} options - Upgrade options.\n   * @return {Graph}          - The copy.\n   */\n  copy(options) {\n    options = options || {};\n\n    if (\n      typeof options.type === 'string' &&\n      options.type !== this.type &&\n      options.type !== 'mixed'\n    )\n      throw new UsageGraphError(\n        `Graph.copy: cannot create an incompatible copy from \"${this.type}\" type to \"${options.type}\" because this would mean losing information about the current graph.`\n      );\n\n    if (\n      typeof options.multi === 'boolean' &&\n      options.multi !== this.multi &&\n      options.multi !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.'\n      );\n\n    if (\n      typeof options.allowSelfLoops === 'boolean' &&\n      options.allowSelfLoops !== this.allowSelfLoops &&\n      options.allowSelfLoops !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.'\n      );\n\n    const graph = this.emptyCopy(options);\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      addEdge(\n        graph,\n        'copy',\n        false,\n        edgeData.undirected,\n        edgeData.key,\n        edgeData.source.key,\n        edgeData.target.key,\n        assign({}, edgeData.attributes)\n      );\n    }\n\n    return graph;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function' &&\n        typeof k !== 'symbol'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Attributes-related.\n */\nattachNodeAttributesMethods(Graph);\nattachEdgeAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n", "/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n", "/**\n * Graphology ESM Endoint\n * =======================\n *\n * Endpoint for ESM modules consumers.\n */\nimport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n} from './classes';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nexport default Graph;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph,\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n};\n", "import * as graphology from \"graphology\";\r\n\r\nlet graph: graphology.DirectedGraph;\r\n\r\nexport const wikiGraphWorkerInterface = {\r\n  setGraph(g: ReturnType<graphology.DirectedGraph[\"export\"]>) {\r\n    graph = new graphology.DirectedGraph().import(g);\r\n  },\r\n  applyIteration(repulsion: number, neighborAttraction: number) {\r\n    applyCoordinateDescentForceIteration(graph, {\r\n      repulsion,\r\n      neighborAttraction,\r\n    });\r\n    return graph.nodes().map((n) => {\r\n      const attribs = graph.getNodeAttributes(n);\r\n      return {\r\n        id: n,\r\n        x: attribs.x,\r\n        y: attribs.y,\r\n      };\r\n    });\r\n  },\r\n};\r\n\r\nfunction makeSpatialHashTable(\r\n  graph: graphology.DirectedGraph,\r\n  xSize: number,\r\n  ySize: number\r\n) {\r\n  let table: string[][] = [];\r\n\r\n  for (let i = 0; i < (xSize + 1) * (ySize + 1); i++) {\r\n    table.push([]);\r\n  }\r\n\r\n  let minX = Infinity;\r\n  let minY = Infinity;\r\n  let maxX = -Infinity;\r\n  let maxY = -Infinity;\r\n\r\n  for (const node of graph.nodes()) {\r\n    const attribs = graph.getNodeAttributes(node);\r\n\r\n    minX = Math.min(minX, attribs.x);\r\n    maxX = Math.max(maxX, attribs.x);\r\n    minY = Math.min(minY, attribs.y);\r\n    maxY = Math.max(maxY, attribs.y);\r\n  }\r\n\r\n  for (const node of graph.nodes()) {\r\n    const attribs = graph.getNodeAttributes(node);\r\n\r\n    let bucketX = Math.floor(((attribs.x - minX) / (maxX - minX)) * xSize);\r\n    let bucketY = Math.floor(((attribs.y - minY) / (maxY - minY)) * ySize);\r\n\r\n    let bucket = bucketX + bucketY * (xSize + 1);\r\n    table[bucket].push(node);\r\n  }\r\n\r\n  return {\r\n    x1: minX,\r\n    y1: minY,\r\n    x2: maxX,\r\n    y2: maxY,\r\n    xSize,\r\n    ySize,\r\n    table,\r\n    getCandidatesWithinBox(\r\n      x1: number,\r\n      y1: number,\r\n      x2: number,\r\n      y2: number\r\n    ): string[][] {\r\n      const buckets: string[][] = [];\r\n      let minBucketX = Math.max(\r\n        0,\r\n        Math.floor(((x1 - minX) / (maxX - minX)) * xSize)\r\n      );\r\n      let minBucketY = Math.max(\r\n        0,\r\n        Math.floor(((y1 - minY) / (maxY - minY)) * ySize)\r\n      );\r\n\r\n      let maxBucketX = Math.min(\r\n        xSize + 1,\r\n        Math.ceil(((x2 - minX) / (maxX - minX)) * xSize)\r\n      );\r\n      let maxBucketY = Math.min(\r\n        ySize + 1,\r\n        Math.ceil(((y2 - minY) / (maxY - minY)) * ySize)\r\n      );\r\n\r\n      for (let y = minBucketY; y < maxBucketY; y++) {\r\n        for (let x = minBucketX; x < maxBucketX; x++) {\r\n          let bucket = x + y * (xSize + 1);\r\n          if (table[bucket]) buckets.push(table[bucket]);\r\n        }\r\n      }\r\n\r\n      return buckets;\r\n    },\r\n  };\r\n}\r\n\r\nexport function applyCoordinateDescentForceIteration(\r\n  graph: graphology.DirectedGraph,\r\n  options: {\r\n    repulsion: number;\r\n    neighborAttraction: number;\r\n  }\r\n) {\r\n  let minX = Infinity;\r\n  let minY = Infinity;\r\n  let maxX = -Infinity;\r\n  let maxY = -Infinity;\r\n\r\n  for (const node of graph.nodes()) {\r\n    const attribs = graph.getNodeAttributes(node);\r\n\r\n    minX = Math.min(minX, attribs.x);\r\n    maxX = Math.max(maxX, attribs.x);\r\n    minY = Math.min(minY, attribs.y);\r\n    maxY = Math.max(maxY, attribs.y);\r\n  }\r\n\r\n  console.time(\"a\");\r\n  console.time(\"c\");\r\n  const ht = makeSpatialHashTable(graph, 100, 100);\r\n  let repulsionRadius = 50;\r\n  console.timeEnd(\"c\");\r\n\r\n  let nodesChecked = 0;\r\n\r\n  // make nodes go away from each other\r\n  for (const node of graph.nodes()) {\r\n    const attribs = graph.getNodeAttributes(node);\r\n\r\n    let x = attribs.x;\r\n    let y = attribs.y;\r\n\r\n    const buckets = ht.getCandidatesWithinBox(\r\n      attribs.x - repulsionRadius,\r\n      attribs.y - repulsionRadius,\r\n      attribs.x + repulsionRadius,\r\n      attribs.y + repulsionRadius\r\n    );\r\n\r\n    for (const bkt of buckets) {\r\n      for (const targetNode of bkt) {\r\n        nodesChecked++;\r\n        const targetAttribs = graph.getNodeAttributes(targetNode);\r\n        const dx = targetAttribs.x - attribs.x;\r\n        const dy = targetAttribs.y - attribs.y;\r\n        const mag = Math.hypot(dx, dy);\r\n\r\n        if (mag < repulsionRadius && mag !== 0) {\r\n          const forceMag = Math.min(3, 50 / mag) * options.repulsion;\r\n          x -= (dx / mag) * forceMag;\r\n          y -= (dy / mag) * forceMag;\r\n        }\r\n      }\r\n    }\r\n\r\n    graph.setNodeAttribute(node, \"x\", x);\r\n    graph.setNodeAttribute(node, \"y\", y);\r\n  }\r\n  console.timeEnd(\"a\");\r\n  console.log(\"checked:\", nodesChecked / graph.nodes().length);\r\n\r\n  console.time(\"b\");\r\n  // move nodes toward their neighbors\r\n  for (const node of graph.nodes()) {\r\n    const neighbors = graph\r\n      .inboundNeighbors(node)\r\n      .concat(graph.outboundNeighbors(node));\r\n    const attribs = graph.getNodeAttributes(node);\r\n    let x = attribs.x;\r\n    let y = attribs.y;\r\n    let neighborcount = neighbors.length;\r\n\r\n    for (const neighbor of neighbors) {\r\n      const targetAttribs = graph.getNodeAttributes(neighbor);\r\n      const dx = targetAttribs.x - attribs.x;\r\n      const dy = targetAttribs.y - attribs.y;\r\n      const mag = Math.hypot(dx, dy);\r\n\r\n      const forceMag =\r\n        (Math.sqrt(mag) * options.neighborAttraction) / (neighborcount + 1);\r\n      if (mag !== 0 && mag > repulsionRadius + forceMag) {\r\n        x += (dx / mag) * forceMag;\r\n        y += (dy / mag) * forceMag;\r\n      }\r\n    }\r\n\r\n    graph.setNodeAttribute(node, \"x\", x);\r\n    graph.setNodeAttribute(node, \"y\", y);\r\n  }\r\n  console.timeEnd(\"b\");\r\n}\r\n", "import { workerifyServer } from \"../common/workerify.js\";\r\nimport { wikiGraphWorkerInterface } from \"./wiki-article-graph-worker-interface.js\";\r\n\r\nconst server = workerifyServer(\r\n  wikiGraphWorkerInterface,\r\n  \"graph\",\r\n  (cb) => {\r\n    const messageListener = (e: MessageEvent) => {\r\n      cb(e.data);\r\n    };\r\n    self.addEventListener(\"message\", messageListener);\r\n    return () => self.removeEventListener(\"message\", messageListener);\r\n  },\r\n  (res) => {\r\n    self.postMessage(res);\r\n  }\r\n);\r\n"],
  "mappings": "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",
  "names": ["require_events", "__commonJSMin", "exports", "module", "R", "ReflectApply", "target", "receiver", "args", "ReflectOwnKeys", "ProcessEmitWarning", "warning", "NumberIsNaN", "value", "EventEmitter", "once", "defaultMaxListeners", "checkListener", "listener", "arg", "n", "_getMaxListeners", "that", "type", "doError", "events", "er", "err", "handler", "len", "listeners", "arrayClone", "_addListener", "prepend", "m", "existing", "w", "onceWrapper", "_onceWrap", "state", "wrapped", "list", "position", "i", "originalListener", "spliceOne", "keys", "key", "_listeners", "unwrap", "evlistener", "unwrapListeners", "emitter", "listenerCount", "arr", "copy", "index", "ret", "name", "resolve", "reject", "errorListener", "resolver", "eventTargetAgnosticAddListener", "addErrorHandlerIfEventEmitter", "flags", "wrapListener", "workerifyServer", "i", "discriminator", "onReceive", "send", "inf", "req", "typedReq", "responseContents", "assignPolyfill", "target", "i", "l", "k", "assign", "getMatchingEdge", "graph", "source", "type", "sourceData", "edge", "isPlainObject", "value", "isEmpty", "o", "privateProperty", "name", "readOnlyProperty", "descriptor", "validateHints", "hints", "incrementalIdStartingFromRandomByte", "chain", "iterables", "current", "step", "emptyIterator", "GraphError", "message", "InvalidArgumentsGraphError", "_InvalidArgumentsGraphError", "NotFoundGraphError", "_NotFoundGraphError", "UsageGraphError", "_UsageGraphError", "MixedNodeData", "key", "attributes", "DirectedNodeData", "UndirectedNodeData", "EdgeData", "undirected", "outKey", "inKey", "adj", "head", "NODE", "SOURCE", "TARGET", "OPPOSITE", "findRelevantNodeData", "method", "mode", "nodeOrEdge", "nameOrEdge", "add1", "add2", "nodeData", "edgeData", "arg1", "arg2", "attachNodeAttributeGetter", "Class", "data", "attachNodeAttributesGetter", "attachNodeAttributeChecker", "attachNodeAttributeSetter", "attachNodeAttributeUpdater", "updater", "attachNodeAttributeRemover", "attachNodeAttributesReplacer", "attachNodeAttributesMerger", "attachNodeAttributesUpdater", "NODE_ATTRIBUTES_METHODS", "element", "attachNodeAttributesMethods", "Graph", "attacher", "attachEdgeAttributeGetter", "attachEdgeAttributesGetter", "attachEdgeAttributeChecker", "attachEdgeAttributeSetter", "attachEdgeAttributeUpdater", "attachEdgeAttributeRemover", "attachEdgeAttributesReplacer", "attachEdgeAttributesMerger", "attachEdgeAttributesUpdater", "EDGE_ATTRIBUTES_METHODS", "attachEdgeAttributesMethods", "EDGES_ITERATION", "forEachSimple", "breakable", "object", "callback", "avoid", "shouldBreak", "forEachMulti", "createIterator", "keys", "forEachForKeySimple", "targetData", "forEachForKeyMulti", "createIteratorForKey", "done", "createEdgeArray", "size", "list", "mask", "iterator", "forEachEdge", "shouldFilter", "createEdgeIterator", "forEachEdgeForNode", "multi", "direction", "fn", "found", "createEdgeArrayForNode", "edges", "createEdgeIteratorForNode", "forEachEdgeForPath", "createEdgeArrayForPath", "createEdgeIteratorForPath", "attachEdgeArrayCreator", "description", "attachForEachEdge", "forEachName", "mapName", "args", "result", "length", "e", "ea", "s", "t", "sa", "ta", "u", "filterName", "reduceName", "initialValue", "accumulator", "attachFindEdge", "findEdgeName", "someName", "everyName", "attachEdgeIteratorCreator", "originalName", "attachEdgeIterationMethods", "NEIGHBORS_ITERATION", "CompositeSetWrapper", "set", "forEachInObjectOnce", "visited", "neighborData", "forEachNeighbor", "createNeighborArrayForNode", "neighbors", "createDedupedObjectIterator", "createNeighborIterator", "attachNeighborArrayCreator", "node", "attachForEachNeighbor", "n", "a", "attachFindNeighbor", "capitalizedSingular", "findName", "attachNeighborIteratorCreator", "iteratorName", "attachNeighborIterationMethods", "forEachAdjacency", "assymetric", "disconnectedNodes", "neighbor", "hasEdges", "serializeNode", "serialized", "serializeEdge", "validateSerializedNode", "validateSerializedEdge", "INSTANCE_ID", "TYPES", "EMITTER_PROPS", "EDGE_ADD_METHODS", "verb", "DEFAULTS", "addNode", "unsafeAddNode", "addEdge", "mustGenerateKey", "eventData", "isSelfLoop", "mergeEdge", "asUpdater", "alreadyExistingEdgeData", "info", "oldAttributes", "sourceWasAdded", "targetWasAdded", "dropEdgeFromData", "_Graph", "options", "NodeDataClass", "instancePrefix", "edgeId", "edgeKeyGenerator", "availableEdgeKey", "prop", "degree", "loops", "nodes", "merge", "_sa", "_ta", "undirectedByDefault", "multiIndex", "label", "tmp", "desc", "dummy", "DirectedGraph", "finalOptions", "UndirectedGraph", "MultiGraph", "MultiDirectedGraph", "MultiUndirectedGraph", "attachStaticFromMethod", "instance", "graph", "wikiGraphWorkerInterface", "g", "DirectedGraph", "repulsion", "neighborAttraction", "applyCoordinateDescentForceIteration", "n", "attribs", "makeSpatialHashTable", "xSize", "ySize", "table", "i", "minX", "minY", "maxX", "maxY", "node", "bucketX", "bucketY", "bucket", "x1", "y1", "x2", "y2", "buckets", "minBucketX", "minBucketY", "maxBucketX", "maxBucketY", "y", "x", "options", "ht", "repulsionRadius", "nodesChecked", "bkt", "targetNode", "targetAttribs", "dx", "dy", "mag", "forceMag", "neighbors", "neighborcount", "neighbor", "server", "workerifyServer", "wikiGraphWorkerInterface", "cb", "messageListener", "e", "res"]
}
