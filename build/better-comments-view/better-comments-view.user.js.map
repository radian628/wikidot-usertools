{
  "version": 3,
  "sources": ["../../src/common/listen-for-element.ts", "../../src/common/throttle.ts", "../../src/common/wait.ts", "../../src/common/localstorage-io.ts", "../../src/common/string-field.ts", "../../src/better-comments-view/filter-by-wiki.ts", "../../src/better-comments-view/scroll-detector.ts", "../../src/better-comments-view/better-comments-view.user.ts"],
  "sourcesContent": ["export function listenForSelector(selector: string) {\r\n  const elem = document.querySelector(selector);\r\n  if (elem) return Promise.resolve(elem);\r\n\r\n  return new Promise<Element>((resolve, reject) => {\r\n    const observer = new MutationObserver(() => {\r\n      const elem = document.querySelector(selector);\r\n      if (elem) {\r\n        observer.disconnect();\r\n        resolve(elem);\r\n      }\r\n    });\r\n    observer.observe(document.body, {\r\n      childList: true,\r\n      subtree: true,\r\n    });\r\n  });\r\n}\r\n\r\nexport function listenForNoSelector(selector: string) {\r\n  const elem = document.querySelector(selector);\r\n  if (!elem) return Promise.resolve();\r\n\r\n  return new Promise<void>((resolve, reject) => {\r\n    const observer = new MutationObserver(() => {\r\n      const elem = document.querySelector(selector);\r\n      if (!elem) {\r\n        observer.disconnect();\r\n        resolve();\r\n      }\r\n    });\r\n    observer.observe(document.body, {\r\n      childList: true,\r\n      subtree: true,\r\n    });\r\n  });\r\n}\r\n", "// clientside rate limiter to avoid hammering wikidot with requests\r\n\r\nexport type Throttled<T extends Function> = T & { _throttled: true };\r\n\r\nexport function throttle<Params extends any[], RetType>(\r\n  callback: (...params: Params) => Promise<RetType>,\r\n  options: {\r\n    limits: {\r\n      // seconds\r\n      duration: number;\r\n      maxRequests: number;\r\n    }[];\r\n    maxConcurrentRequests: number;\r\n  }\r\n): Throttled<typeof callback> {\r\n  let queue: {\r\n    params: Params;\r\n    callback: (rt: RetType) => void;\r\n  }[] = [];\r\n\r\n  const requestHistorySize = options.limits.reduce(\r\n    (prev, curr) => Math.max(prev, curr.duration),\r\n    0\r\n  );\r\n\r\n  let requestHistory: {\r\n    time: number;\r\n  }[] = [];\r\n\r\n  const pendingRequests = new Set<Promise<RetType>>();\r\n\r\n  setInterval(() => {\r\n    while (true) {\r\n      // dont do anything if there are no pending requests\r\n      const req = queue.at(0);\r\n      if (!req) return;\r\n\r\n      // get current time\r\n      const time = Date.now();\r\n\r\n      // filter out request history entries that are too old\r\n      requestHistory = requestHistory.filter(\r\n        (h) => (time - h.time) / 1000 <= requestHistorySize\r\n      );\r\n\r\n      // ensure we haven't reached the max pending requests\r\n      if (pendingRequests.size >= options.maxConcurrentRequests) return;\r\n\r\n      // ensure we haven't hit a rate limit\r\n      for (const l of options.limits) {\r\n        let reqCount = 0;\r\n        for (const h of requestHistory) {\r\n          const secondsAgo = (time - h.time) / 1000;\r\n          if (secondsAgo <= l.duration) {\r\n            reqCount++;\r\n          }\r\n        }\r\n        if (reqCount >= l.maxRequests) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      // remove first entry in queue\r\n      queue.shift();\r\n\r\n      // add request to history\r\n      requestHistory.push({\r\n        time: Date.now(),\r\n      });\r\n\r\n      // actually execute the request\r\n      const responsePromise = callback(...req.params);\r\n      pendingRequests.add(responsePromise);\r\n      (async () => {\r\n        const response = await responsePromise;\r\n        req.callback(response);\r\n        pendingRequests.delete(responsePromise);\r\n      })();\r\n    }\r\n  });\r\n\r\n  const fn = (...params: Params) => {\r\n    return new Promise<RetType>((resolve, reject) => {\r\n      queue.push({\r\n        params,\r\n        callback: (rt) => {\r\n          resolve(rt);\r\n        },\r\n      });\r\n    });\r\n  };\r\n\r\n  fn._throttled = true as true;\r\n  return fn;\r\n}\r\n", "export function waitUntil<T>(\r\n  fn: (cb: T extends void ? () => void : (t: T) => void) => () => void\r\n): Promise<T> {\r\n  return new Promise((resolve, reject) => {\r\n    // @ts-expect-error\r\n    const unsub = fn((t) => {\r\n      unsub();\r\n      resolve(t);\r\n    });\r\n  });\r\n}\r\n\r\nexport function wait(ms: number) {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(resolve, ms);\r\n  });\r\n}\r\n", "import { PubSub } from \"./pubsub.js\";\r\n\r\nexport function registerStorageItem<T>(name: string, defaultValue: T) {\r\n  name = \"radian628-wikidot-usertools-\" + name;\r\n  let subscriptions = new Set<(t: T) => void>();\r\n  const obj: PubSub<T> = {\r\n    get(): T {\r\n      const it = localStorage.getItem(name);\r\n      if (!it) return defaultValue;\r\n      try {\r\n        return JSON.parse(it);\r\n      } catch {\r\n        return defaultValue;\r\n      }\r\n    },\r\n    set(content: T) {\r\n      localStorage.setItem(name, JSON.stringify(content));\r\n      for (const s of subscriptions) {\r\n        s(content);\r\n      }\r\n    },\r\n    subscribe(cb) {\r\n      subscriptions.add(cb);\r\n      return () => {\r\n        subscriptions.delete(cb);\r\n      };\r\n    },\r\n  };\r\n\r\n  if (!obj.get() && defaultValue) obj.set(defaultValue);\r\n\r\n  return obj;\r\n}\r\n", "import { PubSub } from \"./pubsub.js\";\r\n\r\nexport function stringField(src: PubSub<string>) {\r\n  const element = document.createElement(\"input\");\r\n  element.value = src.get();\r\n  const unsub = src.subscribe((t) => {\r\n    if (element.value !== t) {\r\n      element.value = t;\r\n    }\r\n  });\r\n  element.oninput = () => {\r\n    src.set(element.value);\r\n  };\r\n  return {\r\n    element,\r\n    unmount: unsub,\r\n  };\r\n}\r\n", "import { registerStorageItem } from \"../common/localstorage-io.js\";\r\nimport { stringField } from \"../common/string-field.js\";\r\n\r\nconst wikiFilter = registerStorageItem(\"filter-by-wiki\", \"\");\r\n\r\nexport function createWikiFilterField() {\r\n  const sf = stringField(wikiFilter);\r\n\r\n  const root = document.createElement(\"div\");\r\n\r\n  root.appendChild(sf.element);\r\n  const docs = document.createElement(\"p\");\r\n  docs.innerText =\r\n    \"Put the wiki slug in the text box above (without quotes) to view posts from only that wiki (e.g. 'scp-wiki', 'scp-sandbox-3', 'scp-wiki-cn', etc.). Leave empty to perform no filtering.\";\r\n  root.appendChild(docs);\r\n\r\n  return {\r\n    element: root,\r\n    wikiFilter,\r\n    unmount: () => {\r\n      sf.unmount();\r\n    },\r\n  };\r\n}\r\n", "export function scrollDetector(upwardsExtent: string): {\r\n  element: HTMLElement;\r\n  onVisible: (cb: () => void) => () => void;\r\n  isVisible: () => boolean;\r\n} {\r\n  const element = document.createElement(\"div\");\r\n  element.style.height = upwardsExtent;\r\n  element.style.marginTop = `-${upwardsExtent}`;\r\n  element.style.pointerEvents = \"none\";\r\n  const callbacks = new Set<() => void>();\r\n\r\n  const it = new IntersectionObserver(\r\n    (r) => {\r\n      console.log(\"intersectionobserver callback\", r);\r\n      for (const e of r) {\r\n        if (!e.isIntersecting) continue;\r\n        _isVisible = true;\r\n        for (const cb of callbacks) {\r\n          cb();\r\n        }\r\n        return;\r\n      }\r\n      _isVisible = false;\r\n    },\r\n    {\r\n      root: null,\r\n      threshold: 0.01,\r\n    }\r\n  );\r\n  it.observe(element);\r\n\r\n  let _isVisible: boolean | undefined = undefined;\r\n  function isVisible() {\r\n    console.log(\"isVisible\", _isVisible);\r\n    if (_isVisible === undefined) {\r\n      for (const e of it.takeRecords()) {\r\n        if (!e.isIntersecting) continue;\r\n        return (_isVisible = true);\r\n      }\r\n      return (_isVisible = false);\r\n    } else {\r\n      return _isVisible;\r\n    }\r\n  }\r\n\r\n  return {\r\n    element,\r\n    onVisible(cb) {\r\n      callbacks.add(cb);\r\n      setTimeout(() => {\r\n        if (isVisible() && callbacks.has(cb)) {\r\n          console.log(\"initially visible\");\r\n          cb();\r\n        }\r\n      });\r\n      return () => {\r\n        callbacks.delete(cb);\r\n      };\r\n    },\r\n    isVisible,\r\n  };\r\n}\r\n", "/*!\r\n// ==UserScript==\r\n// @name        UserInfo Better Comments View \r\n// @match       *://*.wikidot.com/user:info/*\r\n// @grant       none\r\n// @version     1.0\r\n// @author      radian628\r\n// @description A nicer way to view Wikidot comments. \r\n// ==/UserScript==\r\n*/\r\n\r\nimport {\r\n  listenForNoSelector,\r\n  listenForSelector,\r\n} from \"../common/listen-for-element.js\";\r\nimport { PubSub } from \"../common/pubsub.js\";\r\nimport { throttle, Throttled } from \"../common/throttle.js\";\r\nimport { waitUntil } from \"../common/wait.js\";\r\nimport { createWikiFilterField } from \"./filter-by-wiki.js\";\r\nimport { scrollDetector } from \"./scroll-detector.js\";\r\n\r\ntype GetUserPageResult = {\r\n  status: \"ok\";\r\n  jsInclude: unknown[];\r\n  cssInclude: unknown[];\r\n  callbackIndex: string;\r\n  CURRENT_TIMESTAMP: number;\r\n  body?: string;\r\n};\r\n\r\nfunction getUserCommentPageTextRaw(userId: string, page: number) {\r\n  return new Promise<GetUserPageResult>((resolve, reject) => {\r\n    OZONE.ajax.requestModule(\r\n      \"userinfo/UserRecentPostsListModule\",\r\n      {\r\n        page,\r\n        userId,\r\n      },\r\n      (result) => {\r\n        resolve(result);\r\n      }\r\n    );\r\n  });\r\n}\r\n\r\nasync function getUserCommentPageElements(\r\n  userId: string,\r\n  page: number,\r\n  getUserCommentPageText: Throttled<typeof getUserCommentPageTextRaw>\r\n) {\r\n  const text = await getUserCommentPageText(userId, page);\r\n  const threadContainer = extractElementFromString(\r\n    text.body ?? \"\",\r\n    \".thread-container\"\r\n  );\r\n  return threadContainer;\r\n}\r\n\r\nfunction extractElementFromString(\r\n  src: string,\r\n  selector: string\r\n): Element | null {\r\n  const div = document.createElement(\"div\");\r\n  div.innerHTML = src;\r\n  return div.querySelector(selector);\r\n}\r\n\r\nexport async function getCommentCount(\r\n  userId: string,\r\n  loadPageAt: (idx: number) => Promise<Element | null>\r\n) {\r\n  const isPageEmpty = async (idx: number) => {\r\n    const page = await loadPageAt(idx);\r\n    return !page || page.children.length === 0;\r\n  };\r\n\r\n  let pageCountUpperBound = 1;\r\n\r\n  // establish an upper bound for the number of pages\r\n  while (true) {\r\n    const isUpperBoundEmpty = await isPageEmpty(pageCountUpperBound);\r\n    if (isUpperBoundEmpty) {\r\n      break;\r\n    }\r\n    pageCountUpperBound *= 2;\r\n  }\r\n\r\n  // establish a lower bound for number of pages\r\n  let pageCountLowerBound = Math.floor(pageCountUpperBound / 2);\r\n\r\n  // perform binary search\r\n  while (Math.abs(pageCountUpperBound - pageCountLowerBound) > 1) {\r\n    let mid = Math.floor((pageCountLowerBound + pageCountUpperBound) / 2);\r\n    const isEmpty = await isPageEmpty(mid);\r\n    if (isEmpty) {\r\n      pageCountUpperBound = mid;\r\n    } else {\r\n      pageCountLowerBound = mid;\r\n    }\r\n  }\r\n\r\n  // calculate number of comments based on number of pages\r\n  return (\r\n    Math.max(0, pageCountLowerBound - 1) * 20 +\r\n    ((await loadPageAt(pageCountLowerBound))?.children.length ?? 0)\r\n  );\r\n}\r\n\r\n// @ts-expect-error\r\nwindow.getUserCommentPageElements = getUserCommentPageElements;\r\n\r\nfunction recentPostsInfiniteScroll(\r\n  recentPostsBox: HTMLDivElement,\r\n  userId: string,\r\n  wikiFilter: PubSub<string>\r\n): () => void {\r\n  let loadedPages = new Map<number, Element | null>();\r\n  let nextPageIndex = 1;\r\n  let doneLoadingPages = false;\r\n\r\n  async function loadNewPage(\r\n    userId: string,\r\n    getUserCommentPageText: Throttled<typeof getUserCommentPageTextRaw>\r\n  ) {\r\n    let idx = nextPageIndex++;\r\n    const page = await loadPageAt(userId, idx, getUserCommentPageText);\r\n    if (!page || page?.children.length == 0) {\r\n      doneLoadingPages = true;\r\n    }\r\n    return page;\r\n  }\r\n\r\n  async function loadPageAt(\r\n    userId: string,\r\n    idx: number,\r\n    getUserCommentPageText: Throttled<typeof getUserCommentPageTextRaw>\r\n  ) {\r\n    if (loadedPages.has(idx)) return loadedPages.get(idx)!;\r\n    return getUserCommentPageElements(userId, idx, getUserCommentPageText).then(\r\n      (page) => {\r\n        loadedPages.set(idx, page);\r\n        return page;\r\n      }\r\n    );\r\n  }\r\n\r\n  const wikifilterUnsub = wikiFilter.subscribe((a) => {\r\n    console.log(\"test\", a, wikiFilter.get());\r\n    applyWikiFilter();\r\n  });\r\n\r\n  function applyWikiFilter() {\r\n    const wikiname = wikiFilter.get().trim();\r\n\r\n    const posts = document.querySelectorAll(\".forum-recent-posts-box .post\");\r\n\r\n    let someVisible = false;\r\n\r\n    for (const post of Array.from(posts)) {\r\n      const linkToPost = post.querySelector(\r\n        \".info > a:nth-last-child(1)\"\r\n      ) as HTMLAnchorElement | null;\r\n\r\n      if (!linkToPost) {\r\n        const errorWarning = document.createElement(\"p\");\r\n        errorWarning.innerText =\r\n          \"Warning: Unable to identify the wiki this post originated from.\";\r\n        errorWarning.style = \"color: red;\";\r\n        errorWarning.className = \"delete-after-post-visibility-updates\";\r\n        post.appendChild(errorWarning);\r\n        someVisible = true;\r\n      } else if (\r\n        wikiname.length === 0 ||\r\n        linkToPost.href.includes(`://${wikiname}.wikidot.com`)\r\n      ) {\r\n        (post as HTMLElement).style.display = \"block\";\r\n        someVisible = true;\r\n      } else {\r\n        (post as HTMLElement).style.display = \"none\";\r\n      }\r\n    }\r\n  }\r\n\r\n  const sd = scrollDetector(\"100vh\");\r\n  const status = document.createElement(\"div\");\r\n  let stop = false;\r\n  recentPostsBox.appendChild(sd.element);\r\n  recentPostsBox.appendChild(status);\r\n\r\n  let commentCountStr = \"???\";\r\n\r\n  let commentCountPromise = (async () => {\r\n    const commentCount = await getCommentCount(userId, (idx) =>\r\n      loadPageAt(\r\n        userId,\r\n        idx,\r\n        throttle(getUserCommentPageTextRaw, {\r\n          maxConcurrentRequests: 5,\r\n          limits: [{ duration: 2, maxRequests: 6 }],\r\n        })\r\n      )\r\n    );\r\n\r\n    commentCountStr = commentCount.toString();\r\n  })();\r\n\r\n  (async () => {\r\n    while (!stop && !doneLoadingPages) {\r\n      // wait until the user has scrolled down\r\n      await waitUntil<void>(sd.onVisible);\r\n      status.innerText = `Loading more comments... (${\r\n        document.querySelectorAll(\".forum-recent-posts-box .post\").length\r\n      } / ${commentCountStr})`;\r\n\r\n      // load and add a new page\r\n      const page = await loadNewPage(\r\n        userId,\r\n        throttle(getUserCommentPageTextRaw, {\r\n          maxConcurrentRequests: 3,\r\n          limits: [{ duration: 1 / 3, maxRequests: 1 }],\r\n        })\r\n      );\r\n      if (page) {\r\n        recentPostsBox.insertBefore(page, sd.element);\r\n        applyWikiFilter();\r\n      }\r\n    }\r\n    await commentCountPromise;\r\n    status.innerText = `All comments for this user have been loaded. (${commentCountStr} / ${commentCountStr})`;\r\n  })();\r\n\r\n  return () => {\r\n    stop = true;\r\n    wikifilterUnsub();\r\n  };\r\n}\r\n\r\n(async () => {\r\n  while (true) {\r\n    // ensure we're on the right page\r\n    const recentPostsBox = (await listenForSelector(\r\n      \".forum-recent-posts-box:has(#forum-recent-posts-list)\"\r\n    )) as HTMLDivElement;\r\n\r\n    // get user's id\r\n    const userId =\r\n      (\r\n        recentPostsBox.querySelector(\r\n          \"#recent-posts-user-id\"\r\n        ) as HTMLInputElement | null\r\n      )?.value ?? \"\";\r\n\r\n    // remove old, paginated contents of the recent posts box\r\n    for (const child of Array.from(recentPostsBox.children)) {\r\n      child.parentElement?.removeChild(child);\r\n    }\r\n    const betterCommentsViewIndicator = document.createElement(\"div\");\r\n    betterCommentsViewIndicator.id = \"better-comments-view-indicator\";\r\n    recentPostsBox.appendChild(betterCommentsViewIndicator);\r\n\r\n    const filter = createWikiFilterField();\r\n    if (recentPostsBox.parentElement) {\r\n      recentPostsBox.parentElement.insertBefore(filter.element, recentPostsBox);\r\n    }\r\n\r\n    const stopInfiniteScroll = recentPostsInfiniteScroll(\r\n      recentPostsBox,\r\n      userId,\r\n      filter.wikiFilter\r\n    );\r\n\r\n    await listenForNoSelector(\"#better-comments-view-indicator\");\r\n    stopInfiniteScroll();\r\n    filter.unmount();\r\n  }\r\n})();\r\n"],
  "mappings": "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",
  "names": ["listenForSelector", "selector", "elem", "resolve", "reject", "observer", "listenForNoSelector", "throttle", "callback", "options", "queue", "requestHistorySize", "prev", "curr", "requestHistory", "pendingRequests", "req", "time", "h", "l", "reqCount", "responsePromise", "response", "fn", "params", "resolve", "reject", "rt", "waitUntil", "fn", "resolve", "reject", "unsub", "t", "registerStorageItem", "name", "defaultValue", "subscriptions", "obj", "it", "content", "s", "cb", "stringField", "src", "element", "unsub", "t", "wikiFilter", "registerStorageItem", "createWikiFilterField", "sf", "stringField", "root", "docs", "scrollDetector", "upwardsExtent", "element", "callbacks", "it", "r", "e", "_isVisible", "cb", "isVisible", "getUserCommentPageTextRaw", "userId", "page", "resolve", "reject", "result", "getUserCommentPageElements", "getUserCommentPageText", "text", "extractElementFromString", "src", "selector", "div", "getCommentCount", "loadPageAt", "isPageEmpty", "idx", "pageCountUpperBound", "pageCountLowerBound", "mid", "recentPostsInfiniteScroll", "recentPostsBox", "wikiFilter", "loadedPages", "nextPageIndex", "doneLoadingPages", "loadNewPage", "wikifilterUnsub", "a", "applyWikiFilter", "wikiname", "posts", "someVisible", "post", "linkToPost", "errorWarning", "sd", "scrollDetector", "status", "stop", "commentCountStr", "commentCountPromise", "throttle", "waitUntil", "listenForSelector", "child", "betterCommentsViewIndicator", "filter", "createWikiFilterField", "stopInfiniteScroll", "listenForNoSelector"]
}
